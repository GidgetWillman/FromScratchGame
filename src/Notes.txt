so we had things in the wrong order, I guess

but it looks like the setup involves:
1) compile and link the shaders ahead of the loop
2) bind glBindVertexArray(VAO)
3) copy vertices array into glBindBuffer(VBO)
4) bind and copy indices array into glBindBuffer(EBO)
5) ENTER RENDERING LOOP
6) call glUseProgram
7) call glBindVertexArray(VAO)
8) call glDrawElements (or glDrawArrays)

VAO = Vertex Array Object
VBO = Vertex Buffer Object
EBO = Element Buffer Object (element array buffer)

Of note, we can make VBO and VAO arrays
when drawing, we just have to specify which entry we're using

so basically we're declaring the shader to draw with
then declaring what to draw
then drawing it



as long as the EBO is set up after VAO and VBO, it should work

glDrawArrays(GLenum mode, 
    GLint first, 
    GLsizei count);

mode declares how to interpret and draw
first marks the starting index in the array
count specifies how many vertices to render

of note, on obj files:
v lines are vertices
vn lines are vertex normals
vt lines are texture coordinates
s lines indicate smooth shading
f lines indicate face indices by vertex/texture/normal
(v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3)

vecn - floats
bvecn - bools
ivecn - integers
uvecn - unsigned integers
dvecn - doubles

vectors are accessed by .x .y .z .w
can also acces by .r .g .b .a (color)
or by .s .t .p .q (texture coordinates)

swizzling: 
vec2 someVec;
vec4 differentVec = someVec.xyxx;
vec3 anotherVec = differentVec.zyw;
vec4 otherVec = someVec.xxxx + anotherVec.yxzy;
use any combination of letters to make a new vector of those components

shaders specify inputs and outputs
vertex shader almost always needs layout (location = X) in vec3 aPos;
fragment shader always needs out vec4 FragColor

shaders go vertex -> fragment (geometry in between but we're not worried about that right now)

uniform variables are global and can be accessed anywhere
they will remain until reset or updated