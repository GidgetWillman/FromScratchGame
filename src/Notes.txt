so we had things in the wrong order, I guess

but it looks like the setup involves:
1) compile and link the shaders ahead of the loop
2) bind glBindVertexArray(VAO)
3) copy vertices array into glBindBuffer(VBO)
4) bind and copy indices array into glBindBuffer(EBO)
5) ENTER RENDERING LOOP
6) call glUseProgram
7) call glBindVertexArray(VAO)
8) call glDrawElements (or glDrawArrays)

VAO = Vertex Array Object
VBO = Vertex Buffer Object
EBO = Element Buffer Object (element array buffer)

Of note, we can make VBO and VAO arrays
when drawing, we just have to specify which entry we're using

so basically we're declaring the shader to draw with
then declaring what to draw
then drawing it



as long as the EBO is set up after VAO and VBO, it should work

glDrawArrays(GLenum mode, 
    GLint first, 
    GLsizei count);

mode declares how to interpret and draw
first marks the starting index in the array
count specifies how many vertices to render

of note, on obj files:
v lines are vertices
vn lines are vertex normals
vt lines are texture coordinates
s lines indicate smooth shading
f lines indicate face indices by vertex/texture/normal
(v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3)

vecn - floats
bvecn - bools
ivecn - integers
uvecn - unsigned integers
dvecn - doubles

vectors are accessed by .x .y .z .w
can also acces by .r .g .b .a (color)
or by .s .t .p .q (texture coordinates)

swizzling: 
vec2 someVec;
vec4 differentVec = someVec.xyxx;
vec3 anotherVec = differentVec.zyw;
vec4 otherVec = someVec.xxxx + anotherVec.yxzy;
use any combination of letters to make a new vector of those components

shaders specify inputs and outputs
vertex shader almost always needs layout (location = X) in vec3 aPos;
fragment shader always needs out vec4 FragColor

shaders go vertex -> fragment (geometry in between but we're not worried about that right now)

uniform variables are global and can be accessed anywhere
they will remain until reset or updated

someStackObject.Function();
someHeapObject->Function();
remember the heap pointer literally points to the function

VECTOR MATH

Scalar vector operations:
-essentially just scaling a vector by multiplying/adding/subtracting
-the simplest, most straightforward vector math, 
    just add/sub/multiply/divide x from everything

Vector negation:
-just multiply the bitch by -1 and it goes in the other direction

Vector addition and subtraction
-just add the matching bits.  vec3 + vec3 is the same as vec3.a + vec3.a, 
    vec3.b + vec3.b, and so on.
-Just remember it's basically x+x and y+y and z+z and you're fine

Vector length:
-pythagorean theorem.  Even in 3D, it's apparently the same.
-add x^2 + y^2 + z^2 and take the square root of the result and that's your length

Dot product:
-dot product is equal to scalar multiplication of their lengths times the
    cosine of the angle between them.
-apparently we calculate the dot product by multiplying the components 
    (x*x, y*y, z*z) and adding up the results.
-we can get an angle from this by inverse cosine.

Cross product:
-defined only in 3D space.  Takes two non-parallel vectors and produces a third
    vector that is orthogonal to both inputs. (it'll be at a 90 degree angle from each)
-hokay this one's complicated.  Basically...
-looks like we multiply each component by the next component
-then multiply by the previous component
-then subtract the results... idk I'll take a screenshot on the learning channel
    in Discord just look there holy shit

MATRICES!!!
-indexed by (i,j) where i is the row and j is the column
-obvious, but of note: opposite of typical graphics coordinates
-(2, 1) would retrieve the second row, first column

Matrix additon/subtraction:
-per element, just like vectors
-only works on matrices of the same dimension

Matrix scalar:
-same as with vectors. if the question is Matrix[]*2, just multiply every matrix
    element by 2 and there's the result.

Matrix multiplication:
-two matrices can only be multiplied if matrix A has the same number of columns as
    matrix B, and is not commutative (A*B != B*A)
-specifically the book says the left matrix and right matrix instead of A and B